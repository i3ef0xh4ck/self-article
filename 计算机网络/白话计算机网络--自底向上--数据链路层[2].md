### 差错检测
这篇来讲讲数据链路层很重要的一个问题就是差错检测。

#### 数据链路差错检测的最重要的一个特点
数据链路层**只做差错检测，不做纠正，检测出错就丢掉。**
#### 奇偶校验
说到差错检测最简单的一种检测方法是奇偶校验。
比如你要传输的串是101，
那么奇偶会在最后加一个==校验位==

> 这个校验位是干什么的呢？存的又是什么呢？

与其说是存什么，不如说它是一个标记，这个校验位的生成需要三步：
1、把被传输串中各个位数相加
2、判断这个数是奇数还是偶数
3、如果是奇数则校验位标记为1，如果是偶数则校验位标记为0

然后接收方的数据链路层就会也对被传输串做这三个步骤得出一个校验位，然后和传过来的校验位做比较，如果相同接收方会认为传输过程中没有出错，会继续传播，如果不相同则接收方会把这个帧直接丢弃。
这个过程我想你也看透了，有很大的问题，所谓的奇偶校验不就是计算1的个数，所以自然而然大家可以提出这样的问题：

>如果被传输串有两个位置发生变化，岂不是接收方根本察觉不到？

没错，所以就出现了CRC，循环冗余检测

#### 循环冗余检测CRC
Cyclic Redundancy Check， CRC
要想弄清楚CRC一定要知道一个方法：
[模“2”除法](https://baike.baidu.com/item/模2除法)
建议大家先去看一下什么是模2除法，再回来继续看CRC，这个除法和我们数字除法很像，只是没有错位，使用了**异或**的概念和计算。相信我，你点出去，5分钟就回来了，很快的。

##### CRC步骤简述
1. 选定一个用于校验的==多项式f(x)==，在被传输串后面加==r==个0 。
2. 用加了r个0的串，模二除法除以==多项式的位串==
3. 用第二步得到的==余数==，填充在r个0的位置。如果位数不足，在余数前面加0补齐到r位。现在得到的这个位串就叫**可校验位串**，也是实际传输的位串。

好了这些很简单，我来一一解释。

- 多项式f(x)以及多项式位串：

	这是自己选定的一个多项式，比如：f(x)=x^3 + x^2 + 1 这个多项式的位串就是1101，怎么来的呢？
	f(x)=1 * x^3 + 1 * x^2 + 0 * x + 1，这就得到1101
- r个0

	r就是你选择的多项式的次数也就是最高阶的指数，这里自然就是3

我们找个例题来过一遍这个过程。
eg.  用CRC来计算101001的可校验位串。
解：
首先我们选多项式，就用上面的f(x)=x^3 + x^2 + 1 ，那么多项式串为1101
r为3	
我们在传输串后面加3个0的到101001000，
用这个串对1101做模二除法，得到余数为1
我们要把1填在r个0的位置，也就是我们要把1补齐成001
然后我们最后得到可校验位串为101001001

这时候我们看到我们实际传输的位串为101001001

> 那你们肯定会问了，接收端拿到这个串怎么知道传输端有没有错？

接收端会用这个串在用模二除法除以多项式串，得到的余数是0的话，接收端就会认为传输过程中没有出错。

综上所述，你们发现了吗？当我们的多项式阶数为1的时候，循环冗余检测神奇的变成了奇偶校验。
**所以差错检测的能力与多项式次数也就是阶数r有关系，r越大，越精确。**

> 这时候另一个问题肯定萦绕在你们脑海，既然这个多项式是我们定的，那么该怎么定？？？

放心这个东西也是被广泛规定好的，不同的协议都有一定的标准，用什么样的CRC。



















